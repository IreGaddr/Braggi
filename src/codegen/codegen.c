/*
 * Braggi - Code Generation Implementation
 * 
 * "Good code generation is like a good cattle brand - 
 * clear, distinctive, and gets the job done!" - Texas Compiler Ranch
 */

#include "braggi/codegen.h"
#include "braggi/braggi_context.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>  // For PATH_MAX

// Forward declaration of internal function
static bool braggi_codegen_generate_file(CodeGenContext* ctx, Source* source, const char* output_path);

// Initialize the code generator
bool braggi_codegen_init(CodeGenContext* ctx, BraggiContext* braggi_ctx, CodeGenOptions options) {
    if (!ctx || !braggi_ctx) {
        return false;
    }
    
    ctx->braggi_ctx = braggi_ctx;
    ctx->options = options;
    ctx->arch_data = NULL;
    
    // Initialize architecture-specific data
    switch (options.arch) {
        case ARCH_X86:
            // TODO: Implement x86 initialization
            break;
        case ARCH_X86_64:
            braggi_codegen_x86_64_init();
            break;
        case ARCH_ARM:
            // TODO: Implement ARM initialization
            break;
        case ARCH_ARM64:
            // TODO: Implement ARM64 initialization
            break;
        case ARCH_WASM:
            // TODO: Implement WASM initialization
            break;
        case ARCH_BYTECODE:
            // TODO: Implement bytecode initialization
            break;
        default:
            return false;
    }
    
    return true;
}

// Generate code from the AST
bool braggi_codegen_generate(CodeGenContext* ctx) {
    if (!ctx || !ctx->braggi_ctx) {
        return false;
    }
    
    // Check if the context has a source file
    if (!ctx->braggi_ctx->source) {
        printf("No source files to generate code for.\n");
        return false;
    }
    
    // Print debug info
    printf("Generating code for source: %s\n", 
           braggi_source_file_get_name(ctx->braggi_ctx->source));
    
    // TODO: Implement actual code generation here
    // This is just a stub implementation for now
    
    // Generate the output file path
    char output_path[PATH_MAX];
    const char* source_name = braggi_source_file_get_name(ctx->braggi_ctx->source);
    
    // Simply append .out for now
    snprintf(output_path, PATH_MAX, "%s.out", source_name);
    
    // Generate code for the source file
    if (!braggi_codegen_generate_file(ctx, ctx->braggi_ctx->source, output_path)) {
        printf("Failed to generate code for %s\n", source_name);
        return false;
    }
    
    printf("Code generation complete. Output written to %s\n", output_path);
    return true;
}

// Implementation of internal function to generate code for a specific file
static bool braggi_codegen_generate_file(CodeGenContext* ctx, Source* source, const char* output_path) {
    if (!ctx || !source || !output_path) {
        return false;
    }
    
    printf("Generating code for %s to %s...\n", 
           braggi_source_file_get_name(source), output_path);
    
    // For now, just write a simple output file with some metadata
    // This is a stub implementation that will be expanded later
    return braggi_codegen_write_output(ctx, output_path);
}

// Write output to a file
bool braggi_codegen_write_output(CodeGenContext* ctx, const char* filename) {
    if (!ctx || !filename) {
        return false;
    }
    
    // For now, just create a dummy output file
    FILE* file = fopen(filename, "w");
    if (!file) {
        return false;
    }
    
    fprintf(file, "// Generated by Braggi Compiler\n");
    fprintf(file, "// Target: %s\n", braggi_codegen_arch_to_string(ctx->options.arch));
    fprintf(file, "// Format: %s\n", braggi_codegen_format_to_string(ctx->options.format));
    
    // TODO: Write actual generated code
    
    fclose(file);
    return true;
}

// Get default code generator options for an architecture
CodeGenOptions braggi_codegen_get_default_options(TargetArch arch) {
    CodeGenOptions options;
    
    options.arch = arch;
    options.format = FORMAT_EXECUTABLE;
    options.optimize = false;
    options.optimization_level = 0;
    options.emit_debug_info = true;
    options.output_file = NULL;
    
    return options;
}

// Get string representation of an architecture
const char* braggi_codegen_arch_to_string(TargetArch arch) {
    switch (arch) {
        case ARCH_X86:
            return "x86";
        case ARCH_X86_64:
            return "x86_64";
        case ARCH_ARM:
            return "ARM";
        case ARCH_ARM64:
            return "ARM64";
        case ARCH_WASM:
            return "WebAssembly";
        case ARCH_BYTECODE:
            return "Bytecode";
        default:
            return "Unknown";
    }
}

// Get string representation of an output format
const char* braggi_codegen_format_to_string(OutputFormat format) {
    switch (format) {
        case FORMAT_OBJECT:
            return "Object";
        case FORMAT_EXECUTABLE:
            return "Executable";
        case FORMAT_LIBRARY:
            return "Library";
        case FORMAT_ASM:
            return "Assembly";
        default:
            return "Unknown";
    }
} 